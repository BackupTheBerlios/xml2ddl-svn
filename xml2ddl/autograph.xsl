<?xml version="1.0" encoding="utf-8"?>

<!--
 Copyright(c) 2005 CF Consulting Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!--
This version shows the basic table relationships, but takes the schemas (table
spaces) into account.
It also shows the table column names.

It now also supports a 'report' xml file that specifies
(include/exclude)(schemas/tables). This will allow for more finely focussed
diagrams.
-->

<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:autograph="http://cfconsulting.ca/autograph/1.0"
    xmlns:fn="http://www.w3.org/2003/11/xpath-functions">

<xsl:output indent="yes" method="text" />

<xsl:key name='schemas_key' match='table' use='@schema' />

<xsl:key name='include_schemas_key'
    match='autograph:report/autograph:includeschemas/autograph:schema'
    use='@name' />
<xsl:key name='exclude_schemas_key'
    match='autograph:report/autograph:excludeschemas/autograph:schema'
    use='@name' />
<xsl:key name='include_tables_key'
    match='autograph:report/autograph:includetables/autograph:table'
    use='@name' />
<xsl:key name='exclude_tables_key'
    match='autograph:report/autograph:excludetables/autograph:table'
    use='@name' />

<xsl:variable name="tablemode"
    select="autograph:report/autograph:graphparams/autograph:tablemode/@name" />
  
<xsl:template match="schema">

<xsl:variable name='ft'
    select="table[
    (
	(count(key('include_schemas_key',@schema))>0) and
	(count(key('exclude_schemas_key',@schema))=0)
    )
    or
    (
	(count(key('include_tables_key',@name)) > 0 ) and
	(count(key('exclude_tables_key',@name)) = 0)
    )]"/>


<xsl:variable name="filtered_tables" select="$ft" />
<xsl:variable name="overrides" select="//autograph:report/autograph:override/autograph:connection"/>

digraph auto_graph
    {
    label="Generated by Auto Graph"

    graph [ rankdir="TB" ];
    graph [fontsize=24];
    edge  [fontsize=24];
    node  [fontsize=24];
    ranksep = 1.5;
    nodesep = 1.25;
    edge
	[
	style="setlinewidth(.1)"

    <xsl:choose>
	<xsl:when test="$tablemode = 'simple'">
	arrowhead="crow"
	</xsl:when>
	<xsl:otherwise>
	<!-- arrowhead="arrow" -->
	</xsl:otherwise>
    </xsl:choose>

	];


    node [
	style="filled"
	fillcolor="ivory2"
	shape="record"
	fontsize="16"
	];

    <xsl:for-each select="$filtered_tables">
    <xsl:value-of select="@name" />
	[

    <xsl:choose>
	<xsl:when test="$tablemode = 'simple'">
	label = "<xsl:value-of select='@name' />"
	</xsl:when>
	<xsl:otherwise>
	label = "{<xsl:value-of select='@name' /> <xsl:for-each
	select="column">|&lt;f<xsl:value-of select="position()"
	/>&gt;<xsl:value-of select="@name" /> </xsl:for-each>}"
	</xsl:otherwise>
    </xsl:choose>
	
	];
    </xsl:for-each>

    <!-- Now create the schema boxes -->

    <xsl:for-each
    select="$filtered_tables[generate-id(.)=generate-id(key('schemas_key',@schema)[1])]">
	<xsl:variable name="curschema" select="@schema"/>

    subgraph cluster<xsl:value-of select="position()" />
	{
	label = "<xsl:value-of select='$curschema' />";
	style=filled;
	fillcolor=azure;
	node [fillcolor=azure2];

	<xsl:for-each select="$filtered_tables[@schema=$curschema]">
	    <xsl:value-of select="@name" />;
	</xsl:for-each>
	};
    </xsl:for-each>

    <!-- and now the table connections -->

    <!--
    I'm doing a bit of a hack here. I prefer my diagrams to have the reference
    tables at the top, and the referring tables at the bottom. I also want
    crow's feet on the referring table side.
    There seems to be a bug in 'dot' (the graphviz processor) where it aborts
    given certain diagram specs. These always seem to be the detailed table
    spec, where the table columns are visible. So for the 'full' table view, I
    won't do the arrow reversing that I'm doing with the simple view.
    -->

    <xsl:for-each select="$filtered_tables">
	<xsl:variable name="thistable" select="." />
	<xsl:for-each select="relations/relation">
	    <xsl:variable name="thisrel" select="." />
	    <xsl:variable name="left"
		select='count(($thistable/column[@name=$thisrel/@column])[1]/preceding-sibling::*) + 1'  />
	    <xsl:variable name="right"
	    select='count((/table[@name=$thisrel/table]/column[@name=$thisrel/@column])[1]/preceding-sibling::*) + 1' />

	    <xsl:choose>
		<xsl:when test="$tablemode = 'simple'">
		<xsl:value-of select="@table" /> -> <xsl:value-of select="$thistable/@name" />;
		</xsl:when>
		<xsl:otherwise>
		<!-- here is where I'm *not* doing the reversal that I would
		like to do. -->
    <xsl:value-of select="$thistable/@name" />:f<xsl:value-of select="$left"
    /> -> <xsl:value-of select="@table" />:f<xsl:value-of select="$right" />;
		</xsl:otherwise>
	    </xsl:choose>

	</xsl:for-each>
    </xsl:for-each>

    <!-- And lastly, let's do the overrides, where we put in connections for
    where there are no foreign keys (but where there is a relationship) -->

    <xsl:for-each select="$overrides">
	<xsl:variable name="thisconn" select="." />

	<xsl:variable name="fromtable"
	    select="$filtered_tables[@name=$thisconn/@from_table]"/>
	<xsl:variable name="totable"
	    select="$filtered_tables[@name=$thisconn/@to_table]"/>

	<!-- these next two bits if bizarre-ness are here because I need
	a field number, and there apparently isn't a way to get the current
	node index from XPath. So I need to count all the siblings before the
	node that we're using -->

	<xsl:variable name="left"
	    select='count(($fromtable/column[@name=$thisconn/@from_column])[1]/preceding-sibling::*) + 1'  />

	<xsl:variable name="right"
	select='count((/table[@name=$thisconn/@to_table]/column[@name=$thiscol/@to_column])[1]/preceding-sibling::*) + 1' />

	<xsl:choose>
	    <xsl:when test="$tablemode = 'simple'">
	    <xsl:value-of select="@to_table" /> -> <xsl:value-of
	    select="@from_table" />;
	    </xsl:when>
	    <xsl:otherwise>
	    <xsl:value-of select="@table" />:f<xsl:value-of select="$right"
	    /> -> <xsl:value-of select="$thisconn/@from_name" />:f<xsl:value-of
	    select="$left" />;
	    </xsl:otherwise>
	</xsl:choose>

    </xsl:for-each>
    };
</xsl:template>

</xsl:stylesheet>

